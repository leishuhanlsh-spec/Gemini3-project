<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lumina NoÃ«l | Local MediaPipe</title>
    
    <!-- Google Fonts (Optional, falls back if offline) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root {
            --gold: #d4af37;
            --cream: #fceea7;
            --dark-bg: #000000;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: 'Times New Roman', serif;
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease-out;
        }

        .loader-content {
            position: relative;
            text-align: center;
            color: var(--gold);
        }

        .tree-icon {
            font-size: 60px;
            color: var(--gold);
            text-shadow: 0 0 20px var(--cream);
            animation: pulse 2s infinite ease-in-out;
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            letter-spacing: 0.2em;
            color: var(--cream);
            margin: 0;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .status-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
            font-style: italic;
        }

        .start-btn {
            margin-top: 30px;
            padding: 10px 30px;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            cursor: pointer;
            opacity: 0;
            transition: all 0.5s;
            pointer-events: none;
        }

        .start-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .start-btn:hover {
            background: var(--gold);
            color: #000;
            box-shadow: 0 0 20px var(--gold);
        }

        /* Decorative Particles for Loader */
        .snow-particle {
            position: absolute;
            background: var(--cream);
            border-radius: 50%;
            opacity: 0.6;
            animation: float 10s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 5px var(--gold)); }
            50% { transform: scale(1.1); filter: drop-shadow(0 0 15px var(--cream)); }
        }

        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.8; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }

        /* Webcam Preview */
        #input_video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 1px solid var(--gold);
            opacity: 0.3;
            z-index: 10;
            display: none; /* Hidden by default, toggled if needed */
        }
        
        #gesture-label {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: var(--cream);
            font-family: 'Cinzel', serif;
            font-size: 14px;
            z-index: 5;
            opacity: 0.7;
            text-shadow: 0 0 5px var(--gold);
        }
    </style>

    <!-- Import Map for Three.js (Still CDN for Three.js unless you have it locally too) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Local MediaPipe Scripts -->
    <!-- æ³¨æ„ï¼šç¡®ä¿ mediapipe æ–‡ä»¶å¤¹åœ¨ html åŒçº§ç›®å½• -->
    <script src="./mediapipe/camera_utils.js"></script>
    <script src="./mediapipe/control_utils.js"></script>
    <script src="./mediapipe/drawing_utils.js"></script>
    <script src="./mediapipe/hands.js"></script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div id="css-particles"></div>
        <div class="loader-content">
            <div class="tree-icon">ðŸŽ„</div>
            <h1>Merry Christmas</h1>
            <div class="status-text" id="status">Loading Local AI Models...</div>
            <button class="start-btn" id="start-btn">ENTER EXPERIENCE</button>
        </div>
    </div>

    <!-- UI Overlay -->
    <div id="gesture-label">Waiting for camera...</div>
    <video id="input_video" autoplay playsinline></video>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            colors: {
                gold: 0xd4af37,
                cream: 0xfceea7,
                red: 0x880000,
                green: 0x004400,
                blue: 0x000088,
                orange: 0xffaa00
            },
            counts: {
                main: 1500,
                dust: 2500
            }
        };

        // --- Globals ---
        let scene, camera, renderer, composer;
        let particles = []; 
        let dustSystem;
        let clock = new THREE.Clock();
        let hands; // MediaPipe Hands instance
        let cameraUtils; // MediaPipe Camera instance
        
        // State Machine
        const STATE = {
            mode: 'RIBBON', // RIBBON, FIREWORK_PRE, FIREWORK, CRYSTAL
            rotationTarget: { x: 0, y: 0 },
            fireworkExploded: false
        };

        // --- Helper: Procedural Texture ---
        function createCandyCaneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = '#aa0000';
            ctx.beginPath();
            for(let i = -64; i < 128; i+=16) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i + 10, 0);
                ctx.lineTo(i - 20, 64);
                ctx.lineTo(i - 30, 64);
            }
            ctx.fill();
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- Class: ParticleManager ---
        class ParticleManager {
            constructor(scene) {
                this.scene = scene;
                this.instances = [];
                this.dummy = new THREE.Object3D();
                
                this.count = CONFIG.counts.main;
                this.currentPositions = new Float32Array(this.count * 3);
                
                this.targets = {
                    ribbon: new Float32Array(this.count * 3),
                    firework: new Float32Array(this.count * 3),
                    crystal: new Float32Array(this.count * 3)
                };
                
                this.velocities = new Float32Array(this.count * 3); 

                this.initMeshes();
                this.calculateLayouts();
                this.initDust();
            }

            initMeshes() {
                const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const candyTex = createCandyCaneTexture();

                const matGold = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.gold, roughness: 0.3, metalness: 0.9 
                });
                const matGreen = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.green, roughness: 0.7, metalness: 0.1 
                });
                const matRed = new THREE.MeshPhysicalMaterial({ 
                    map: candyTex, roughness: 0.2, metalness: 0.1, clearcoat: 1.0 
                });
                const matLight = new THREE.MeshPhysicalMaterial({
                    color: CONFIG.colors.cream, emissive: CONFIG.colors.gold, emissiveIntensity: 2
                });

                this.groups = [
                    { mesh: new THREE.InstancedMesh(boxGeo, matGold, this.count / 4), index: 0 },
                    { mesh: new THREE.InstancedMesh(boxGeo, matGreen, this.count / 4), index: 0 },
                    { mesh: new THREE.InstancedMesh(sphereGeo, matRed, this.count / 4), index: 0 },
                    { mesh: new THREE.InstancedMesh(sphereGeo, matLight, this.count / 4), index: 0 }
                ];

                this.groups.forEach(g => {
                    g.mesh.castShadow = true;
                    g.mesh.receiveShadow = true;
                    this.scene.add(g.mesh);
                });
            }

            initDust() {
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<CONFIG.counts.dust; i++) {
                    pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({
                    color: CONFIG.colors.gold, size: 0.3, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending
                });
                this.dust = new THREE.Points(geo, mat);
                this.scene.add(this.dust);
            }

            calculateLayouts() {
                for (let i = 0; i < this.count; i++) {
                    // 1. RIBBON
                    const t = (i / this.count) * 25;
                    const h = i / this.count;
                    const r = 15 * (1 - h) + 0.5;
                    const x1 = Math.cos(t) * r;
                    const z1 = Math.sin(t) * r;
                    const y1 = h * 40 - 20;

                    this.targets.ribbon[i*3] = x1;
                    this.targets.ribbon[i*3+1] = y1;
                    this.targets.ribbon[i*3+2] = z1;

                    // 2. CRYSTAL
                    let x3, y3, z3;
                    if (i < this.count * 0.7) {
                        const phi = Math.acos( -1 + ( 2 * i ) / (this.count * 0.7) );
                        const theta = Math.sqrt( (this.count * 0.7) * Math.PI ) * phi;
                        const r3 = 18;
                        x3 = r3 * Math.cos(theta) * Math.sin(phi);
                        y3 = r3 * Math.sin(theta) * Math.sin(phi);
                        z3 = r3 * Math.cos(phi);
                    } else {
                        const idx = i - this.count * 0.7;
                        const total = this.count * 0.3;
                        const hp = idx / total;
                        const rInner = 8 * (1 - hp);
                        const angle = hp * 20;
                        x3 = Math.cos(angle) * rInner;
                        z3 = Math.sin(angle) * rInner;
                        y3 = hp * 16 - 8;
                    }
                    this.targets.crystal[i*3] = x3;
                    this.targets.crystal[i*3+1] = y3;
                    this.targets.crystal[i*3+2] = z3;

                    // 3. FIREWORK CENTER
                    this.targets.firework[i*3] = (Math.random()-0.5) * 2;
                    this.targets.firework[i*3+1] = (Math.random()-0.5) * 2;
                    this.targets.firework[i*3+2] = (Math.random()-0.5) * 2;
                    
                    // Velocity
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const speed = 0.5 + Math.random() * 1.5;
                    this.velocities[i*3] = speed * Math.sin(phi) * Math.cos(theta);
                    this.velocities[i*3+1] = speed * Math.sin(phi) * Math.sin(theta);
                    this.velocities[i*3+2] = speed * Math.cos(phi);

                    // Init
                    this.currentPositions[i*3] = x1;
                    this.currentPositions[i*3+1] = y1;
                    this.currentPositions[i*3+2] = z1;
                }
            }

            update(delta) {
                let targetArray = this.targets.ribbon;
                let lerpFactor = 0.05;

                if (STATE.mode === 'CRYSTAL') {
                    targetArray = this.targets.crystal;
                    STATE.fireworkExploded = false;
                } else if (STATE.mode === 'FIREWORK_PRE') {
                    targetArray = this.targets.firework;
                    lerpFactor = 0.1;
                    STATE.fireworkExploded = false;
                } else if (STATE.mode === 'FIREWORK') {
                    if (!STATE.fireworkExploded) STATE.fireworkExploded = true;
                }

                let globalCounter = 0;
                this.groups.forEach((group) => {
                    const count = group.mesh.count;
                    for (let j = 0; j < count; j++) {
                        const idx = globalCounter + j;
                        if (idx >= this.count) break;

                        if (STATE.mode === 'FIREWORK') {
                            this.currentPositions[idx*3] += this.velocities[idx*3] * (delta * 30);
                            this.currentPositions[idx*3+1] += this.velocities[idx*3+1] * (delta * 30);
                            this.currentPositions[idx*3+2] += this.velocities[idx*3+2] * (delta * 30);
                            
                            this.velocities[idx*3+1] -= 0.02 * delta; // Gravity
                            this.velocities[idx*3] *= 0.98;
                            this.velocities[idx*3+1] *= 0.98;
                            this.velocities[idx*3+2] *= 0.98;
                        } else {
                            const tx = targetArray[idx*3];
                            const ty = targetArray[idx*3+1];
                            const tz = targetArray[idx*3+2];
                            
                            this.currentPositions[idx*3] += (tx - this.currentPositions[idx*3]) * lerpFactor;
                            this.currentPositions[idx*3+1] += (ty - this.currentPositions[idx*3]) * lerpFactor;
                            this.currentPositions[idx*3+2] += (tz - this.currentPositions[idx*3]) * lerpFactor;
                        }

                        let x = this.currentPositions[idx*3];
                        let y = this.currentPositions[idx*3+1];
                        let z = this.currentPositions[idx*3+2];

                        if (STATE.mode === 'RIBBON') {
                            y += Math.sin(clock.getElapsedTime() * 2 + x * 0.5) * 0.2;
                        }

                        this.dummy.position.set(x, y, z);
                        
                        let s = STATE.mode === 'FIREWORK_PRE' ? 0.5 : 1.0;
                        this.dummy.scale.set(s,s,s);
                        this.dummy.rotation.set(clock.getElapsedTime()*0.5, clock.getElapsedTime()*0.5, 0);
                        this.dummy.updateMatrix();
                        
                        group.mesh.setMatrixAt(j, this.dummy.matrix);
                    }
                    group.mesh.instanceMatrix.needsUpdate = true;
                    globalCounter += count;
                });

                if(this.dust) {
                    this.dust.rotation.y += 0.05 * delta;
                    const pos = this.dust.geometry.attributes.position.array;
                    for(let i=1; i<pos.length; i+=3) {
                        pos[i] -= delta * 2;
                        if(pos[i] < -50) pos[i] = 50;
                    }
                    this.dust.geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        // --- Init Functions ---
        async function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.gold).multiplyScalar(0.02);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post Proc
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Environment
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            
            const ambient = new THREE.AmbientLight(CONFIG.colors.cream, 0.5);
            scene.add(ambient);
            const pLight = new THREE.PointLight(CONFIG.colors.orange, 2, 50);
            pLight.position.set(0, 10, 0);
            scene.add(pLight);
            const spotGold = new THREE.SpotLight(CONFIG.colors.gold, 1200);
            spotGold.position.set(30, 40, 40);
            spotGold.castShadow = true;
            scene.add(spotGold);
            const spotBlue = new THREE.SpotLight(CONFIG.colors.blue, 600);
            spotBlue.position.set(-30, 20, -30);
            scene.add(spotBlue);

            // Content
            particles = new ParticleManager(scene);
            createCSSParticles();

            // Setup MediaPipe
            setupMediaPipeLocal();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createCSSParticles() {
            const container = document.getElementById('css-particles');
            const colors = [CONFIG.colors.cream, 0xffffff, 0x880000];
            for(let i=0; i<30; i++) {
                const p = document.createElement('div');
                p.className = 'snow-particle';
                const size = Math.random() * 10 + 2;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                p.style.left = Math.random() * 100 + 'vw';
                p.style.animationDuration = (Math.random() * 5 + 5) + 's';
                p.style.backgroundColor = '#' + colors[Math.floor(Math.random()*colors.length)].toString(16);
                container.appendChild(p);
            }
        }

        // --- Local MediaPipe Setup ---
        function setupMediaPipeLocal() {
            const videoElement = document.getElementById('input_video');
            const statusEl = document.getElementById('status');

            try {
                // Initialize Hands from global 'window.Hands' (loaded via script tag)
                hands = new window.Hands({locateFile: (file) => {
                    // æŒ‡å‘æœ¬åœ° mediapipe ç›®å½•
                    return `mediapipe/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);

                statusEl.innerText = "System Ready. Click Enter.";
                const btn = document.getElementById('start-btn');
                btn.classList.add('visible');
                
                btn.onclick = () => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
                    
                    // Start Camera using MediaPipe Utils
                    cameraUtils = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({image: videoElement});
                        },
                        width: 1280,
                        height: 720
                    });
                    cameraUtils.start();
                };

            } catch (error) {
                console.error(error);
                statusEl.innerText = "Error initializing local MediaPipe.";
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                detectGestures(landmarks);
            }
        }

        function detectGestures(landmarks) {
            // Mapping: Palm (9) to Rotation
            const palm = landmarks[9];
            // x, y are normalized 0-1
            const targetRotY = (palm.x - 0.5) * 3; 
            const targetRotX = (palm.y - 0.5) * 3;
            STATE.rotationTarget.x = targetRotX;
            STATE.rotationTarget.y = targetRotY;

            // Gestures
            const thumb = landmarks[4];
            const index = landmarks[8];
            const wrist = landmarks[0];
            const tips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]];

            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            
            let avgDist = 0;
            tips.forEach(t => {
                avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y);
            });
            avgDist /= 4;

            let currentGesture = 'Unknown';
            if (pinchDist < 0.05) currentGesture = 'PINCH';
            else if (avgDist < 0.25) currentGesture = 'FIST';
            else if (avgDist > 0.35) currentGesture = 'OPEN';

            const label = document.getElementById('gesture-label');
            label.innerText = `Gesture: ${currentGesture} | Mode: ${STATE.mode}`;

            // State Transitions
            if (currentGesture === 'PINCH') {
                if (STATE.mode !== 'FIREWORK') STATE.mode = 'FIREWORK_PRE';
            } else if (currentGesture === 'OPEN') {
                if (STATE.mode === 'FIREWORK_PRE') STATE.mode = 'FIREWORK';
                else if (STATE.mode !== 'FIREWORK') STATE.mode = 'RIBBON';
            } else if (currentGesture === 'FIST') {
                STATE.mode = 'CRYSTAL';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Smooth Scene Rotation
            scene.rotation.y += (STATE.rotationTarget.y - scene.rotation.y) * 0.05;
            scene.rotation.x += (STATE.rotationTarget.x - scene.rotation.x) * 0.05;

            if(particles) particles.update(delta);
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
